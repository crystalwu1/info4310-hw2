<html>
    <head>
        <meta charset="UTF-8">
        <script src="https://d3js.org/d3.v7.min.js"></script>
    </head>

    <!-- css styles -->
    <style>

    </style>
    
    <body>
        <!-- buttons -->
        <select id="selectButton"></select>

        <h1>Scores vs. Distance</h1>

        <!-- svg -->
        <svg id="edu_viz" height="350" width="500" style="margin:20px"></svg>

        <h1>Background vs. Distance</h2>

        <!-- svg -->
        <svg id="bg_viz" height="350" width="500" style="margin:20px"></svg>

        <script>
            // build map
        const loadScatter = async function() {

                // create scatter
                const edu_scatter = d3.select("#edu_viz");
                const bg_scatter = d3.select("#bg_viz");

                // width of both scatter plots are the same, given that their sizes are the same
                // code inspired by prof rz's notes in https://jeffrz.github.io/info4310-sp2022/notes/22.02.07.notes.htm
                const width = edu_scatter.attr("width");
                const height = edu_scatter.attr("height");
                const margin =  {top: 15, right: 15, bottom: 40, left: 50};
                const chartWidth = width - margin.left - margin.right;
                const chartHeight = height - margin.top - margin.right;

                let edu_annotations = edu_scatter.append("g").attr("id","annotations");
                let edu_chartArea = edu_scatter.append("g").attr("id","points")
                    .attr("transform","translate("+margin.left+","+margin.top+")");  

                let bg_annotations = bg_scatter.append("g").attr("id","annotations");
                let bg_chartArea = bg_scatter.append("g").attr("id","points")
                    .attr("transform","translate("+margin.left+","+margin.top+")");  

                // load dataset
                const college_csv = await d3.csv("CollegeDistance.csv");
                console.log(college_csv);

                // filter dataset
                // change types as necessary
                college_csv.forEach((d, i) => {
                    d['score'] = Number(d['score']);
                    d['urban'] = Number(d['urban']);
                    d['unemp'] = Number(d['unemp']);
                    d['wage'] = Number(d['wage']);
                    d['distance'] = Number(d['distance']);
                    d['tuition'] = Number(d['tuition']);
                    d['education'] = Number(d['education']);
                });

                // remove rows where education is not twelve (exclude non-seniors)
                college_filtered = college_csv.filter((d) => d["education"] === 12 );
                console.log(college_filtered);

                // group income values
                // code found from https://github.com/d3/d3-array/blob/main/README.md#group
                let incomeKeys = Array.from(d3.group(college_filtered, d => d.income), ([key, value]) => (key));

                // add options to the select button
                d3.select("#selectButton")
                    .selectAll('myOptions')
     	            .data(incomeKeys)
                    .enter()
    	            .append('option')
                    .text(function (d) { return d; }) // text showed in the menu
                    .attr("value", function (d) { return d; }) // corresponding value returned by the button

                // create extent
                const scoreExtent = d3.extent(college_filtered, d => d['score']);
                const scoreScale = d3.scaleLinear().domain(scoreExtent).range([0, chartWidth]);
                const wageExtent = d3.extent(college_filtered, d => d['wage']);
                const wageScale = d3.scaleLinear().domain(wageExtent).range([0, chartWidth]);
                const distanceExtent = d3.extent(college_filtered, d => d['distance']);
                // tried doing a log scale but didn't return valid numbers
                const distanceScale = d3.scaleLinear().domain(distanceExtent).range([chartHeight, 0]);

                // create custom color scale for gender
                var colors = ["red", "blue"];
                const colorScale = d3.scaleOrdinal().domain(["gender"]).range(colors);

                let leftAxis = d3.axisLeft(distanceScale)
                    .tickFormat(d3.format(""));
                let leftGridlines = d3.axisLeft(distanceScale)
                    .tickSize(-chartWidth-10)
                    .tickFormat("");
                let edu_bottomAxis = d3.axisBottom(scoreScale)
                    .tickFormat(d3.format("~f"));  // exact value without commas
                let edu_bottomGridlines = d3.axisBottom(scoreScale)
                    .tickSize(-chartHeight-10)
                    .tickFormat("");

                let bg_bottomAxis = d3.axisBottom(wageScale)
                    .tickFormat(d3.format("~f"));  // exact value without commas
                let bg_bottomGridlines = d3.axisBottom(wageScale)
                    .tickSize(-chartHeight-10)
                    .tickFormat("");
                
                // create axes and gridlines
                edu_annotations.append("g")
                    .attr("class", "y axis")
                    .attr("transform",`translate(${margin.left-10},${margin.top})`)
                    .call(leftAxis);
                edu_annotations.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform",`translate(${margin.left-10},${margin.top})`)
                    .call(leftGridlines);
                edu_annotations.append("g")
                    .attr("class", "x axis")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                    .call(edu_bottomAxis);
                edu_annotations.append("g")
                    .attr("class", "x gridlines")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                    .call(edu_bottomGridlines);

                bg_annotations.append("g")
                    .attr("class", "y axis")
                    .attr("transform",`translate(${margin.left-10},${margin.top})`)
                    .call(leftAxis);
                bg_annotations.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform",`translate(${margin.left-10},${margin.top})`)
                    .call(leftGridlines);
                bg_annotations.append("g")
                    .attr("class", "x axis")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                    .call(bg_bottomAxis);
                bg_annotations.append("g")
                    .attr("class", "x gridlines")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                    .call(bg_bottomGridlines);

                // function to create circles
                function createCircles(chartArea, data, xScale, xCol) {
                    let circles = chartArea.selectAll("circle.point").data(data)
                    .join(enter => enter.append("circle")
                        .attr("class","point")
                        .attr("opacity", 0.8)
                        )
                    .attr("cx", d => xScale(d[xCol]))
                    .attr("cy", d => distanceScale(d['distance']))
                    .attr("r", 2)
                    .attr("fill", d => colorScale(d['gender']));
                }

                createCircles(edu_chartArea, college_filtered, scoreScale, 'score')
                createCircles(bg_chartArea, college_filtered, wageScale, 'wage')
            
                // code inspired from https://www.d3-graph-gallery.com/graph/line_filter.html
                // update scatter based on selection
                function update(selectedGroup) {
                    // filter dataset based on button selection
                    var filtered = college_filtered.filter(function(d){return d.income == selectedGroup})

                    // give new data to circles
                    createCircles(edu_chartArea, filtered, scoreScale, 'score')
                    createCircles(bg_chartArea, filtered, wageScale, 'wage')
                    // edu_circles
                    //     .datum(filtered)
                        // .transition()
                        // .duration(1000)
                    //     .attr("d", d3.circle()
                    //         .x(function(d) { return scoreScale(d.score) })
                    //         .y(function(d) { return distanceScale(d.distance) })
                    //     )
                    //     // .attr("stroke", function(d){ return myColor(selectedGroup) })
                }

                // when an option is selected, call update 
                d3.select("#selectButton").on("change", function(d) {
                    // recover the option that has been chosen
                    var selectedOption = d3.select(this).property("value")
                    // run the updateChart function with this selected option
                    update(selectedOption)
                })
            };
            loadScatter();

        </script>
    </body>
</html>