<html>
    <head>
        <meta charset="UTF-8">
        <script src="https://d3js.org/d3.v7.min.js"></script>
    </head>

    <!-- css styles -->
    <style>

    </style>

    <body>
        <!-- buttons -->
        <div id="wrapper" style="display:flex; margin: 2%;">
          <div  style="max-width: 65%; margin: 1%">
              <div id="title" style="width:100%; height:10%; margin-top: 2%; margin-bottom: 7%;">
                <h1> Title </h1>
                <h3> Lydia Kim (lmk225), Crystal Wu (cw683) </h3>
                <p> Description </p>
              </div>
              <div id="graph-wrapper" style="width:100%; height: 80%; display: flex; flex-wrap: wrap">
                  <div>
                    <h1>Scores vs. Distance</h1>
                    <svg id="edu_viz" height="350" width="500" style="margin-top:20px"></svg>
                  </div>

                  <div>
                    <h1>Background vs. Distance</h2>
                    <svg id="bg_viz" height="350" width="500" style="margin-top:20px"></svg>
                  </div>
              </div>
              <div id="graph-wrapper" style="width:100%; height: 5%; display: flex;">
                <button type="button">low</button>
                <button type="button">high</button>
                <select id="selectButton"></select>
              </div>
          </div>
          <div id="side" style="width: 25%; height: 90%; margin: 3%">
              <h2>Among students with .... test scores from .... counties , ....</h2>
              <svg id="eth_viz" height="300" width="300" style="margin:20px"></svg>
              <p>Parents Attended College</p>
              <svg id="ped_viz" height="100" width="400" style="overflow: visible;"></svg>
              <div id="my_dataviz"></div>
              <!-- <svg id="home_viz" height="200" width="200" style="margin:20px"></svg> -->
              <!-- <svg id="inc_viz" height="200" width="200" style="margin:20px"></svg> -->
          </div>
        </div>


        <script>
            // build map
        const loadScatter = async function() {

                // create scatter
                const edu_scatter = d3.select("#edu_viz");
                const bg_scatter = d3.select("#bg_viz");
                const eth_scatter = d3.select("#eth_viz");
                const ped_scatter = d3.select("#ped_viz");

                // width of both scatter plots are the same, given that their sizes are the same
                // code inspired by prof rz's notes in https://jeffrz.github.io/info4310-sp2022/notes/22.02.07.notes.htm
                const width = edu_scatter.attr("width");
                const height = edu_scatter.attr("height");
                const margin =  {top: 15, right: 15, bottom: 40, left: 50};
                const chartWidth = width - margin.left - margin.right;
                const chartHeight = height - margin.top - margin.right;

                let edu_annotations = edu_scatter.append("g").attr("id","annotations");
                let edu_chartArea = edu_scatter.append("g").attr("id","points")
                    .attr("transform","translate("+margin.left+","+margin.top+")");

                let bg_annotations = bg_scatter.append("g").attr("id","annotations");
                let bg_chartArea = bg_scatter.append("g").attr("id","points")
                    .attr("transform","translate("+margin.left+","+margin.top+")");

                let eth_annotations = eth_scatter.append("g").attr("id","annotations");
                let eth_chartArea = eth_scatter.append("g").attr("id","ethpoints")
                    .attr("transform","translate("+margin.left+","+margin.top+")");

                let ped_annotations = ped_scatter.append("g").attr("id","annotations");
                let ped_chartArea = ped_scatter.append("g").attr("id","points")
                    .attr("transform","translate("+5+","+margin.top+")");

                // load dataset
                const college_csv = await d3.csv("CollegeDistance.csv");
                console.log(college_csv);

                let scores = []
                let backgr = []
                // filter dataset
                // change types as necessary
                college_csv.forEach((d, i) => {
                    d['score'] = Number(d['score']);
                    d['urban'] = Number(d['urban']);
                    d['unemp'] = Number(d['unemp']);
                    d['wage'] = Number(d['wage']);
                    d['distance'] = Number(d['distance']);
                    d['tuition'] = Number(d['tuition']);
                    d['education'] = Number(d['education']);
                    scores.push(Number(d['score']));
                    backgr.push(Number(d['wage']));
                });

                scores = scores.sort()
                backgr = backgr.sort()

                //lm is 33%, mh 66%. use extent below for min/max
                scores_lm = d3.quantile(scores, 0.33)
                scores_mh = d3.quantile(scores, 0.66)
                backgr_lm = d3.quantile(backgr, 0.33)
                backgr_mh = d3.quantile(backgr, 0.66)

                console.log(scores_lm, scores_mh, backgr_lm, backgr_mh)

                // remove rows where education is not twelve (exclude non-seniors)
                college_filtered = college_csv.filter((d) => d["education"] === 12 );
                console.log(college_filtered);

                // group income values
                // code found from https://github.com/d3/d3-array/blob/main/README.md#group
                let incomeKeys = Array.from(d3.group(college_filtered, d => d.income), ([key, value]) => (key));

                // add options to the select button
                d3.select("#selectButton")
                    .selectAll('myOptions')
     	            .data(incomeKeys)
                    .enter()
    	            .append('option')
                    .text(function (d) { return d; }) // text showed in the menu
                    .attr("value", function (d) { return d; }) // corresponding value returned by the button

                // create extent
                const scoreExtent = d3.extent(college_filtered, d => d['score']);
                const scoreScale = d3.scaleLinear().domain(scoreExtent).range([0, chartWidth]);
                const wageExtent = d3.extent(college_filtered, d => d['wage']);
                const wageScale = d3.scaleLinear().domain(wageExtent).range([0, chartWidth]);
                const distanceExtent = d3.extent(college_filtered, d => d['distance']);
                // tried doing a log scale but didn't return valid numbers
                const distanceScale = d3.scaleLinear().domain(distanceExtent).range([chartHeight, 0]);


                // create custom color scale for gender
                var colors = ["red", "blue"];
                const colorScale = d3.scaleOrdinal().domain(["gender"]).range(colors);

                let leftAxis = d3.axisLeft(distanceScale)
                    .tickFormat(d3.format(""));
                let leftGridlines = d3.axisLeft(distanceScale)
                    .tickSize(-chartWidth-10)
                    .tickFormat("");
                let edu_bottomAxis = d3.axisBottom(scoreScale)
                    .tickFormat(d3.format("~f"));  // exact value without commas
                let edu_bottomGridlines = d3.axisBottom(scoreScale)
                    .tickSize(-chartHeight-10)
                    .tickFormat("");

                let bg_bottomAxis = d3.axisBottom(wageScale)
                    .tickFormat(d3.format("~f"));  // exact value without commas
                let bg_bottomGridlines = d3.axisBottom(wageScale)
                    .tickSize(-chartHeight-10)
                    .tickFormat("");

            // create axes and gridlines
            edu_annotations.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(leftAxis);
            edu_annotations.append("g")
                .attr("class", "y gridlines")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(leftGridlines);
            edu_annotations.append("g")
                .attr("class", "x axis")
                .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                .call(edu_bottomAxis);
            edu_annotations.append("g")
                .attr("class", "x gridlines")
                .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                .call(edu_bottomGridlines);

            bg_annotations.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(leftAxis);
            bg_annotations.append("g")
                .attr("class", "y gridlines")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(leftGridlines);
            bg_annotations.append("g")
                .attr("class", "x axis")
                .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                .call(bg_bottomAxis);
            bg_annotations.append("g")
                .attr("class", "x gridlines")
                .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                .call(bg_bottomGridlines);

            // add circles
            let edu_circles = edu_chartArea.selectAll("circle.point").data(college_filtered)
                .join(enter => enter.append("circle")
                    .attr("class","point")
                    .attr("opacity", 0.8)
                    )
                .attr("cx", d => scoreScale(d['score']))
                .attr("cy", d => distanceScale(d['distance']))
                .attr("r", 2)
                .attr("fill", d => colorScale(d['gender']));

            let bg_circles = bg_chartArea.selectAll("circle.point").data(college_filtered)
                .join(enter => enter.append("circle")
                    .attr("class","point")
                    .attr("opacity", 0.8)
                    )
                .attr("cx", d => wageScale(d['wage']))
                .attr("cy", d => distanceScale(d['distance']))
                .attr("r", 2)
                .attr("fill", d => colorScale(d['gender']));

            //Side Bar Graphs
            var eth = {"hispanic": 0, "afam": 0, "other": 0}
            var inc = {"low": 0, "high": 0}
            var home = {"yes": 0, "no": 0}
            var ped = {"mom": 0, "dad": 0, "both": 0, "neither": 0}

            college_filtered.forEach((d, i) => {
                eth[d["ethnicity"]] += 1;
                inc[d["income"]] += 1;
                home[d["home"]] += 1;
                if (d["fcollege"] == "yes" && d["mcollege"] == "yes") {
                  ped["both"] += 1
                  ped["mom"] += 1
                  ped["dad"] += 1
                } else if (d["fcollege"] == "yes") {
                  ped["dad"] += 1
                } else if (d["mcollege"] == "yes") {
                  ped["mom"] += 1
                }
                else {
                  ped["neither"] += 1
                }
            });

            console.log(eth)
            console.log(ped)
            console.log(home)
            console.log(inc)

            let side = d3.select("#side")
            side.append("br")
            side.append("text").text(`${Math.round(home["yes"]/(home["no"]+home["yes"])*100)}%'s families own homes`)
            side.append("br")
            // side.append("text").text(`${Math.round(inc["low"]/(inc["high"]+inc["low"])*100)}% have parents that attended college`)
            side.append("text").text(`${Math.round(inc["low"]/(inc["high"]+inc["low"])*100)}% are from low income families`)

            //PARENT EDUCATION HORIZONTAL BAR CHART
            let one = ped["dad"] + ped["mom"] - ped["both"] - ped["both"]
            let both = ped["both"]
            let none = ped["neither"]
            let pedScale = d3.scaleLinear().domain([0,none + one + both]).range([0,ped_scatter.attr("width") - margin.left - margin.right])

            function ped_start(section) {
              if (section == "none") {
                return pedScale(0)
              } else if (section == "one") {
                return pedScale(none)
              } else {
                return pedScale(none + one)
              }
            }

            function ped_length(section, ped) {
              let one = ped["dad"] + ped["mom"] - ped["both"] - ped["both"]
              let both = ped["both"]
              let none = ped["neither"]
              if (section == "none") {
                return pedScale(none)
              } else if (section == "one") {
                return pedScale(one)
              } else {
                return pedScale(both)
              }
            }
            let ped_rect = ped_chartArea.selectAll("rect.all").data(["none", "one", "both"])
                .join("rect")
                .attr("class", "all")
                .attr("x", d => ped_start(d))
                .attr("y", 0)
                .attr("width", d => ped_length(d, ped))
                .attr("height", 50)
                .attr("fill", "coral")
                .attr("id", d => d);

            var ped2 = {"mom": 30, "dad": 30, "both": 20, "neither": 800}
            let ped_filter = ped_chartArea.selectAll("rect.filteer").data(["none", "one", "both"])
                .join("rect")
                .attr("class", "filter")
                .attr("x", d => ped_start(d))
                .attr("y", 0)
                .attr("width", d => ped_length(d, ped2))
                .attr("height", 50)
                .attr("fill", "pink")
                .attr("id", d => d);

            const hover = ped_scatter.append("g")
                               .attr("visibility","hidden")
            const txt = hover.append("rect")
                       .attr("fill", "black")
                       // .attr("text-anchor","start")
                       // .attr("alignment-baseline","hanging")
                       .attr("x", 0)
                       .attr("y", 0)
                       .attr("width", 100)
                       .attr("height", 100)
                       .style("font-weight", "bold");


            let ped_outlines = ped_chartArea.selectAll("rect.outline").data(["none", "one", "both"])
                .enter()
                .append('rect')
                .attr("class", "outline")
                .attr("x", d => ped_start(d))
                .attr("y", 0)
                .attr("width", d => ped_length(d, ped))
                .attr("height", 50)
                .attr("fill-opacity", "0")
                .attr("stroke", 'black')
                .attr("id", d => d)
                .on("mouseover", function(d) {
                  d3.select(this)
                    .transition().duration(100)
                    .attr("stroke-width", 3)
                    hover.style("visibility", "visible")
                    txt.attr("x", d3.select(this).attr("x") + d3.select(this).attr("width")/2)
                    txt.attr("y", d3.select(this).attr("height"))

                    console.log()

                })
                .on("mouseout", function(d) {
                  d3.select(this)
                    .transition().duration(100)
                    .attr("stroke-width", 1)
                    hover.style("visibility", "hidden")
                })



            //ETHNICITY BAR CHART
            ethdata = Object.entries(eth)

            let ethChartWidth = Number(eth_scatter.attr("width"))- margin.left - margin.right;
            let ethChartHeight = Number(eth_scatter.attr("height"))- margin.top - margin.bottom;
            const ethScale = d3.scaleOrdinal().domain(["afam", "hispanic", "other"]).range([0, ethChartWidth/2, ethChartWidth]);

            const freqExtent = d3.extent(Object.values(eth));
            const freqScale = d3.scaleLinear().domain([0, freqExtent[1]]).range([ethChartHeight, 0]);

            let ethleftAxis = d3.axisLeft(freqScale)
            let ethleftGridlines = d3.axisLeft(freqScale)
                                  .tickSize(-ethChartWidth-10)
                                  .tickFormat("")
            eth_annotations.append("g")
              .attr("class", "y axis")
              .attr("transform",`translate(${margin.left-10},${margin.top})`)
              .call(ethleftAxis)
            eth_annotations.append("g")
              .attr("class", "y gridlines")
              .attr("transform",`translate(${margin.left-10},${margin.top})`)
              .call(ethleftGridlines);

              // X axis
              let ethbottomAxis = d3.axisBottom(ethScale)
              let ethbottomGridlines = d3.axisBottom(ethScale)
                                      .tickSize(-ethChartHeight-10)
                                      .tickFormat("")
              eth_annotations.append("g")
                .attr("class", "x axis")
                .attr("transform",`translate(${margin.left},${Number(ethChartHeight)+margin.top})`)
                .call(ethbottomAxis);
              eth_annotations.append("g")
                .attr("class", "x gridlines")
                .attr("transform",`translate(${margin.left},${Number(ethChartHeight)+margin.top})`)
                .call(ethbottomGridlines);

              let rects = d3.select("#ethpoints").selectAll("rect.all").data(ethdata)
                                      .join("rect")
                                      .attr("class", "all")
                                      .attr("label", d => d[0])
                                      .attr("amt", d => d[1])
                                      .attr("x", d => ethScale(d[0])-4)
                                      .attr("y", d => freqScale(d[1]))
                                      .attr("height", d => {
                                        console.log(freqScale(d[1]));
                                        return chartHeight - freqScale(d[1] - 350)})
                                      .attr("width", 8)
                                      .attr("fill", "orange" );

              var eth2 = {"hispanic": 200, "afam": 150, "other": 100}
              let rects_filter = d3.select("#ethpoints").selectAll("rect.filter").data(Object.entries(eth2))
                                      .join("rect")
                                      .attr("class", "filter")
                                      .attr("label", d => d[0])
                                      .attr("amt", d => d[1])
                                      .attr("x", d => ethScale(d[0])-4)
                                      .attr("y", d => freqScale(d[1]))
                                      .attr("height", d => {
                                        console.log(freqScale(d[1]));
                                        return chartHeight - freqScale(d[1] - 350)})
                                      .attr("width", 8)
                                      .attr("fill", "pink" );

                // create axes and gridlines
                edu_annotations.append("g")
                    .attr("class", "y axis")
                    .attr("transform",`translate(${margin.left-10},${margin.top})`)
                    .call(leftAxis);
                edu_annotations.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform",`translate(${margin.left-10},${margin.top})`)
                    .call(leftGridlines);
                edu_annotations.append("g")
                    .attr("class", "x axis")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                    .call(edu_bottomAxis);
                edu_annotations.append("g")
                    .attr("class", "x gridlines")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                    .call(edu_bottomGridlines);

                bg_annotations.append("g")
                    .attr("class", "y axis")
                    .attr("transform",`translate(${margin.left-10},${margin.top})`)
                    .call(leftAxis);
                bg_annotations.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform",`translate(${margin.left-10},${margin.top})`)
                    .call(leftGridlines);
                bg_annotations.append("g")
                    .attr("class", "x axis")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                    .call(bg_bottomAxis);
                bg_annotations.append("g")
                    .attr("class", "x gridlines")
                    .attr("transform",`translate(${margin.left},${chartHeight+margin.top-5})`)
                    .call(bg_bottomGridlines);

                // function to create circles
                function createCircles(chartArea, data, xScale, xCol) {
                    let circles = chartArea.selectAll("circle.point").data(data)
                    .join(enter => enter.append("circle")
                        .attr("class","point")
                        .attr("opacity", 0.8)
                        )
                    .attr("cx", d => xScale(d[xCol]))
                    .attr("cy", d => distanceScale(d['distance']))
                    .attr("r", 2)
                    .attr("fill", d => colorScale(d['gender']));
                }

                createCircles(edu_chartArea, college_filtered, scoreScale, 'score')
                createCircles(bg_chartArea, college_filtered, wageScale, 'wage')

                // code inspired from https://www.d3-graph-gallery.com/graph/line_filter.html
                // update scatter based on selection
                function update(selectedGroup) {
                    // filter dataset based on button selection
                    var filtered = college_filtered.filter(function(d){return d.income == selectedGroup})

                    // give new data to circles
                    createCircles(edu_chartArea, filtered, scoreScale, 'score')
                    createCircles(bg_chartArea, filtered, wageScale, 'wage')
                    // edu_circles
                    //     .datum(filtered)
                    //     .transition()
                    //     .duration(1000)
                    //     .attr("d", d3.circle()
                    //         .x(function(d) { return scoreScale(d.score) })
                    //         .y(function(d) { return distanceScale(d.distance) })
                    //     )
                    //     // .attr("stroke", function(d){ return myColor(selectedGroup) })
                }

                // when an option is selected, call update
                d3.select("#selectButton").on("change", function(d) {
                    // recover the option that has been chosen
                    var selectedOption = d3.select(this).property("value")
                    // run the updateChart function with this selected option
                    update(selectedOption)
                })
            };
            loadScatter();

        </script>
    </body>
</html>
